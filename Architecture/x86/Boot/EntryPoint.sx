#===-- EntryPoint.sx - Entry Point for Booting in x86 ---------------------------------------------------*- ASM -*-===#
#
# Copyright (c) 2020 Oever Gonz√°lez
#
#  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
#  the License. You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
#  an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
#  specific language governing permissions and limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#
#===----------------------------------------------------------------------------------------------------------------===#
#/
#/ \file
#/ This file is the entry point for booting in x86. This is the first code executed by the Main Executable, the address
#/ where the CPU jumps after performing the bootloading sequence.
#/
#===----------------------------------------------------------------------------------------------------------------===#

#include <config.h>
#define __FILENAME__ "EntryPoint.sx"
#include <CompilerMagic/AssemblerMagic.h>

/// start is the real entry point. It is the first thing that is found in the binary image, and it's the very first
/// thing to be executed when we have full control over the CPU. For x86, this will save the Multiboot2 registers, setup
/// the main stack and finally perform a long call to the C entry point.
NAKED_GLOBAL_FUNCTION(.start, start)
  XCHG bx, bx # BOCHS magic breakpoint
  LEA esi, iEAX
  LEA edi, iEBX
  MOV [esi], eax  # Temporary save EAX, which contains the Multiboot2 magic number
  MOV [edi], ebx  # Temporary save EAX, which contains the address of the Multiboot2 data structure
  LEA esp, stackStart  # Setup the stack
  MOV ebp, esp
  MOV eax, [edi]  # Restore and push EBX
  PUSH eax
  MOV eax, [esi]  # Restore and push EAX
  PUSH eax
  CALL secondEntryPoint
  CALL miserableFail
NAKED_GLOBAL_FUNCTION_EPILOG(start)
LOCAL_BSS_DATA(iEAX, 4)  # 4: sizeof (eax): 32 bit
LOCAL_BSS_DATA(iEBX, 4)  # 4: sizeof (ebx): 32 bit

/// miserableFail is a global function that will fail miserably when an irrecuperable error is detected. This is only
/// true for the very early boot process.
NAKED_GLOBAL_FUNCTION(.start, miserableFail)
  HLT
  JMP miserableFail
NAKED_GLOBAL_FUNCTION_EPILOG(miserableFail)

# Those are placeholders (needed because LLD will not identify the sections correctly when no data is in the sections)
# but they are only needed when no data is in the section. Most likely to not happen ever but anyway...

NAKED_GLOBAL_FUNCTION(.text, textPlaceholder)
  JMP textPlaceholder
NAKED_GLOBAL_FUNCTION_EPILOG(textPlaceholder)

GLOBAL_DATA(dataPlaceholder)
  .string "dataPlaceholder"
GLOBAL_DATA_EPILOG(dataPlaceholder)

GLOBAL_RODATA(rodataPlaceholder)
  .string "rodataPlaceholder"
GLOBAL_DATA_EPILOG(rodataPlaceholder)

GLOBAL_BSS_DATA(bssPlaceholder, 1)
GLOBAL_STACK_DATA(stackPlaceholder, 1)
