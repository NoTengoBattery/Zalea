/*===-- MainExecutableLinkerBase.in - The Base Linker Script -----------------------------------------------*- C -*-===*
 *
 * Copyright (c) 2020 Oever Gonz√°lez
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 *  the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 *  an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 *  specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * @formatter:off
 *
 *===---------------------------------------------------------------------------------------------------------------===*
 *
 * \file
 * This is the base of all linker scripts, so we include the whole file and use the macros inside the template to decide
 * which sections to use and how to fill them.
 *
 *===--------------------------------------------------------------------------------------------------------------===*/

#ifndef ZALEA_MAINEXECUTABLELINKERBASE_IN
#define ZALEA_MAINEXECUTABLELINKERBASE_IN

#include "LinkerScriptDefinitions.in"
#include <config.h>

#ifdef KERNEL_LINKER_GNU

PHDRS {
    start PT_LOAD FLAGS (PF_RX) ;
    multiboot PT_LOAD FLAGS (PF_R) ;
    code PT_LOAD FLAGS (PF_RX) ;
    data PT_LOAD FLAGS (PF_RW) ;
    rodata PT_LOAD FLAGS (PF_R) ;
}

SECTIONS {
    _SEGMENT_START("start-segment")
    .start ALIGN_COMMONPAGE : AT ( MACHINE_LOAD_ADDRESS /* MACHINE_LOAD_ADDRESS */ ) {
        PROVIDE ( imageStart = . );
        *(.start);
    } :start
    ALIGNED_CPS_SEGMENT_START("multiboot-segment")
    .multiboot2 ALIGN_MINI : ALIGN_MINI {
        KEEP (*(.multiboot2));
        ASSERT (((. - imageStart) < 0x8000), "Multiboot header is out of bounds. Reduce the size of '.start' section.");
    } :multiboot
    ALIGNED_CPS_SEGMENT_START("text-segment")
    .text ALIGN_MINI : ALIGN_MINI {
        *(.text.unlikely);
        *(.text.hot);
        *(SORT(.text.sorted.*));
        *(.text .text.*);
    } :code
    ALIGNED_CPS_SEGMENT_START("data-segment")
    .data ALIGN_MINI : ALIGN_MINI {
        *(.data);
    } :data
    .eh_frame ALIGN_MINI : ALIGN_MINI ONLY_IF_RW {
        KEEP(*(.eh_frame));
        *(.eh_frame.*);
    }
    ALIGNED_CPS_SEGMENT_START("rodata-segment")
    .rodata ALIGN_MINI : ALIGN_MINI {
        *(.rodata);
    } :rodata
    .note.gnu.build-id ALIGN_MICRO : ALIGN_MICRO {
        *(.note.gnu.build-id);
    }
    .eh_frame_hdr ALIGN_MINI : ALIGN_MINI {
        *(.eh_frame_hdr);
        *(.eh_frame_entry .eh_frame_entry.*);
    }
    .eh_frame ALIGN_MINI : ALIGN_MINI ONLY_IF_RO {
        KEEP (*(.eh_frame));
        *(.eh_frame.*);
    }
    /* The stack and bss section, those sections are at the very end of the executable and extends to the image end */
    ALIGNED_CPS_SEGMENT_START("bss-segment")
    .bss ALIGN_MINI (NOLOAD) : ALIGN_MINI {
        PROVIDE ( bssStart = . );
        *(.bss);
        *(COMMON);
        PROVIDE ( bssEnd = . );
     }
     /* Adjust bss to the next page, so we have that RW page between 2 RO pages (just like .data) */
     . = ALIGN_COMMONPAGE;
     /* Leave 1 pages between bss and stack (it's a RO page which will rise exception upon stack overflow) */
     . += MINI_ALIGN; . = ALIGN_COMMONPAGE;
     .stack ALIGN_MINI (NOLOAD) : ALIGN_MINI {
#ifndef MACHINE_STACK_DOWNWARDS
        PROVIDE ( stackStart = . );
        PROVIDE ( stackLowermost = . );
#else
        PROVIDE ( stackEnd = . );
        PROVIDE ( stackLowermost = . );
#endif
        *(.stack);
        . = stackLowermost + MACHINE_STACK_SIZE;
#ifdef MACHINE_STACK_DOWNWARDS
        PROVIDE ( stackStart = . );
        PROVIDE ( imageEnd = . );
#else
        PROVIDE ( stackEnd = . );
        PROVIDE ( imageEnd = . );
#endif
    }

    /* Run 3 special assertions that will ensure the correct alignment of the entry point, load address and stack */
    ASSERT_VIRTUAL_ADDRESS
    ASSERT_LOAD_ADDRESS
    ASSERT_STACK_SIZE

    /* Sections emitted by the compiler (they are stripped in the final binary) */
    .comment 0 : {
        *(.comment);
    }
#ifdef KERNEL_ARM
    .ARM.attributes 0 : {
        KEEP (*(.ARM.attributes));
    }
#endif

#else
#error "What linker are you using?"
#endif
}

#endif //ZALEA_MAINEXECUTABLELINKERBASE_IN
