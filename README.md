# The Zalea microkernel

The Zalea microkernel is a Toy OS microkernel. It is designed for "modern
machines", and it's designed to be portable, modular, compact, small and fast.
It contains some features of big kernels, such as Linux's Device Tree (an
equivalent), the usage of SIMD instructions among other features.

It's build system is based on CMake, a fully custom CMake build system with many
language extensions implemented in Python. This allows the build system to be
smarter, for example, allowing it to export it's current settings to then use it
as a machine's default configuration.

It can compile a JSON file full of properties to a C source code file (which
then is compiled in the microkernel image), which is the equivalent of the Linux
Device Tree Blob. It allows to export the current CMake configuration into a
valid CMake script to be included as an initial cache.

Among that, it generates a `config.h` file full of macros that allows
conditional feature compilation and selection, detecting the build environment,
configure the runtime features at build time among other things. All the
configuration is centralized in the CMake cache and automatically generated by
the build system.

This project can be build in Windows, macOS and any recent Linux distribution.
It can be built, currently, for x86 and some ARM machines. This is a big work in
progress, so not that much features are enabled now.

The microkernel source code also contains some kernel extensions that can be
loaded to support more hardware. The basic drivers are always built in the
microkernel image, and further modules are loaded when the hardware is detected,
or upon user request.

The core modules included in the microkernel are (work in progress):
- Runtime: things like enabling the FPU, stack protector, emulations...
  - A subset of the C library
  - A subset of the C++ language
  - JSON Properties
  - SSE, NEON, Context Saving, etc...
  - Dynamic Loader/Linker and binary format support (like ELF)
  - Exception Handler, Stack Unwinder and Register Dump
  - Kernel Panic
- Entry Point: the first code executed at boot
- InterruptDispatcher: a generic driver to dispatch hardware interrupts
- InterruptController: platform specific Interrupt Controller driver
- RingBuffer: print kernel messages to a special buffer in memory
- MemoryAllocator: reserve blocks of memory for the system
- PageKeeper: generic driver to keep control of memory pages
- MMU: platform specific driver that is the backend of the PageKeeper
- SystemTicker: perform asynchronous operations routinely
- SystemTimer: platform specific System Timer driver
- VirtualFilesystem: virtual files and sockets for kernel and user-mode
- FAT32: the modules and the microkernel image will be in a FAT32 partition
- AnonymousPages: extend physical memory using compressed or permanent storage
- BIOS: basic I/O drivers required to load the rest of the modules
- KernelScheduler: perform basic scheduling of kernel tasks
- SystemSockets: allow processes, modules and programs to communicate
- CryptoCore: chippers, MACs, Checksums, HASHes and compressors
- DebuggerBinding: allow the modules and the microkernel to be debugged
- ModuleLoader: Load kernel modules to memory and hook them to the kernel

Loadable modules include (no work done yet):
- Console: generic driver to write to a console
- Framebuffer: generic driver to paint in a framebuffer
- AudioMixer: generic driver for mixing audio
- ZerrinFilesystem: filesystem driver for the user-mode programs
- TCP/IP(v6) and UDP/IP(v6): layer 3 and up networking stack
- Ethernet: a generic layer 2 Ethernet driver
- IEEE80211: a generic layer 2 stack for wireless devices
- UniversalHost: a generic USB host layer
- \<Network drivers>: drivers for layer 1 network cards
- \<Storage drivers>: storage I/O drivers
- \<Sound card drivers>: reproduce the output of the AudioMixer
- \<USB drivers>: HID, UAS, Mass Storage and more USB drivers
- SystemCalls: allow user-mode programs to request actions to the kernel
- UserScheduler: schedule and run user-mode tasks
- UserExecutables: load, link and run user-mode executables

## Dependencies

In order to build this project, you will need:

- CMake (3.15) and an adequate build tool
  - for macOS you need Xcode (with AppleClang 11 or better)
  - for Windows you can use Ninja, but MinGW is probably a better option
  - for Linux, please install your distro's development tools
- Python 3 (3.7)
  - with an active connection to the internet, because the build system will
    install a custom Python Virtual Environment with all the needed packages
- A suitable compiler for building the project
  - you can use the Clang compiler version 9.0.0 or better
  - or the GNU Compiler Collection version 9.0 or better
  - or Intel's ICC compiler version 19.0 or better
- Binary utilities to perform the final image generation
  - `objcopy` is needed, but can be found in either
    - LLVM version 9.0.0 or better
    - GNU Binutils version 2.33 or better
    - alternatively, you can use the GNU Gold linker

Some extra features that might be useful:

- ccache: speed up builds by using a compiler cache
- clang-tidy: LLVM's static analyzer
- clangd: a server for smart features for IDEs
- CLion IDE: this project is developed by it's author in CLion
- Code::Blocks: an alternative open source and free IDE
- cpplint: a C++ static analyzer written in Python (automatically installed)
- cppcheck: a C/C++ static analyzer with a nice GUI
- Doxygen: generate a searchable HTML web page with the project's documentation
- GNU Debugger or LLVM's LLDB: debug running code in a remote or virtual machine
- GNU GRUB bootloader (for x86): the only usable Multiboot2 bootloader
- openocd (Open On-Chip Debugger): debug an embedded system using JTAG
- qemu system: run a virtual system for testing purposes 

# Supported targets

The supported targets are available under the Architecture subdirectory. This is
a big work in progress, but the currently supported targets are:

- Intel (x86) Pentium 4 with SSE2 (Legacy BIOS machines from 2002 and onwards)
- Raspberry Pi 2 Model B, the QEMU machine is fine
- ARM RealView Platform Explorer (Cortex-A9), the QEMU machine is fine
- ARM Versatile Express (Cortex-A15), the QEMU machine is fine
- MIPS Creator CI20 (MIPS32), you will need a physical device
